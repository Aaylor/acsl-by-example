(* ---------------------------------------------------------- *)
(* --- Global Definitions                                 --- *)
(* ---------------------------------------------------------- *)

function L_Capacity
    (Mint_0:(addr,int) farray,
    s_0:addr) :
    int =
    Mint_0[shift(s_0, 1)]

function L_Size
    (Mint_0:(addr,int) farray,
    s_0:addr) :
    int =
    Mint_0[shift(s_0, 2)]

predicate P_Full
    (Mint_0:(addr,int) farray,
    s_0:addr) =
    L_Capacity(Mint_0, s_0) = L_Size(Mint_0, s_0)

function L_Storage
    (Mptr_0:(addr,addr) farray,
    s_0:addr) :
    addr =
    Mptr_0[shift(s_0, 0)]

predicate P_Valid
    (Malloc_0:int farray,
    Mptr_0:(addr,addr) farray,
    Mint_0:(addr,int) farray,
    s_0:addr) =
    let x_0 = L_Capacity(Mint_0, s_0) : int in
    let x_1 = L_Size(Mint_0, s_0) : int in
    let a_0 = shift(L_Storage(Mptr_0, s_0), 0) : addr in (0 < x_0) and
    (0 <= x_1) and (x_1 <= x_0) and valid_rw(Malloc_0, s_0, 3) and
    valid_rw(Malloc_0, a_0, x_0) and separated(s_0, 3, a_0, x_0)

predicate P_EqualRanges_1_
    (Mint_0:(addr,int) farray,
    Mint_1:(addr,int) farray,
    a_0:addr,
    n_0:int,
    b_0:addr) =
    forall i_0 : int. (i_0 < n_0) -> (0 <= i_0) ->
    (Mint_0[shift(b_0, i_0)] = Mint_1[shift(a_0, i_0)])

predicate P_Equal
    (Mptr_0:(addr,addr) farray,
    Mint_0:(addr,int) farray,
    Mptr_1:(addr,addr) farray,
    Mint_1:(addr,int) farray,
    s_0:addr,
    t_0:addr) =
    let x_0 = L_Size(Mint_1, s_0) : int in (x_0 = L_Size(Mint_0, t_0)) and
    P_EqualRanges_1_(Mint_0, Mint_1, L_Storage(Mptr_1, s_0), x_0,
      L_Storage(Mptr_0, t_0))

axiom Q_TL_Capacity:
  forall s_0 : addr.
  forall Mint_0 : (addr,int) farray
  [L_Capacity(Mint_0, s_0)].
  is_uint32(L_Capacity(Mint_0, s_0))

axiom Q_StackEqualTransitive:
  forall Mint_2,Mint_0,Mint_1 : (addr,int) farray.
    forall Mptr_2,Mptr_0,Mptr_1 : (addr,addr) farray.
    forall s_0,t_0,u_0 : addr.
    P_Equal(Mptr_2, Mint_2, Mptr_1, Mint_1, t_0, u_0) ->
    P_Equal(Mptr_1, Mint_1, Mptr_0, Mint_0, s_0, t_0) ->
    P_Equal(Mptr_2, Mint_2, Mptr_0, Mint_0, s_0, u_0)

axiom Q_StackEqualSymmetric:
  forall Mint_0,Mint_1 : (addr,int) farray.
    forall Mptr_0,Mptr_1 : (addr,addr) farray. forall s_0,t_0 : addr.
    P_Equal(Mptr_1, Mint_1, Mptr_0, Mint_0, s_0, t_0) ->
    P_Equal(Mptr_0, Mint_0, Mptr_1, Mint_1, t_0, s_0)

axiom Q_StackEqualReflexive:
  forall Mint_0 : (addr,int) farray. forall Mptr_0 : (addr,addr) farray.
    forall s_0 : addr. P_Equal(Mptr_0, Mint_0, Mptr_0, Mint_0, s_0, s_0)

axiom Q_TL_Size:
  forall s_0 : addr.
  forall Mint_0 : (addr,int) farray
  [L_Size(Mint_0, s_0)].
  is_uint32(L_Size(Mint_0, s_0))

