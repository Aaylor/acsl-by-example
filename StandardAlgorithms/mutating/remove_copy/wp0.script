(* Generated by Frama-C WP *)

Goal typed_ref_external_remove_copy_loop_inv_kept_preserved_part1.
Hint kept,part-0,preserved,remove_copy.
Proof.
  unfold P_PreserveCount in *.
  intros.

  remember t_1 as M0.
  remember a_1 as A.
  remember a   as B.
  remember i_1 as v.
  remember i_2 as n.
  remember i0  as x.

  rewrite shift_zero in *.
  rewrite shift_zero in *.
  unfold shift_sint32.

  assert(X: M0 .[shift A i] = x  \/  M0.[ shift A i] <> x) by tauto.
  elim X.
  {
    intros Y.
    rewrite Q_CountOneHit; auto with zarith.
    symmetry.
    replace (1 + i - L_Count M0 A i v) with (1 + (i - L_Count M0 A i v)) by omega.
    rewrite Q_CountOneHit; auto with zarith.
    {
      rewrite Q_CountRead with (t_1 := M0); auto with zarith.
      {
         symmetry.
         rewrite Q_CountRead with (t_1 := M0); auto with zarith.

         unfold P_EqualRanges_2_.
         intros.
         rewrite access_update_neq; auto.
         apply separated_1 with (n) (n); auto with zarith.
         apply separated_sym; assumption.
      }
      {
         unfold P_EqualRanges_2_.
         intros.
         rewrite access_update_neq; auto.
         apply shift_injective_neq; auto with zarith.
      }
    }
    rewrite access_update; auto.
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
  }
  {
    intros Y.
    rewrite <- Q_CountOneMiss; auto with zarith.
    {
      symmetry.
      replace (1 + i - L_Count M0 A i v) with (1 + (i - L_Count M0 A i v)) by omega.
      rewrite <- Q_CountOneMiss; auto with zarith.
      {
        rewrite Q_CountRead with (t_1 := M0); auto with zarith.
        {
           symmetry.
           rewrite Q_CountRead with (t_1 := M0); auto with zarith.

           unfold P_EqualRanges_2_.
           intros.
           rewrite access_update_neq; auto.
           apply separated_1 with (n) (n); auto with zarith.
           apply separated_sym; assumption.
        }
        {
          unfold P_EqualRanges_2_.
          intros.
          rewrite access_update_neq; auto.
          apply shift_injective_neq; auto with zarith.
        }
      }
      rewrite access_update; auto.
    }
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
  }
Qed.

Goal typed_ref_external_remove_copy_loop_inv_removed_preserved_part1.
Hint part-0,preserved,remove_copy,removed.
Proof.
(* --------------------------------------
  
From 'typed_ref_external_remove_copy_loop_inv_kept_preserved_part1': 
  unfold P_PreserveCount in *.
  intros.

  remember Mint_0 as M0.
  remember a_0 as a.
  remember b_0 as b.
  remember i_0 as i.
  remember v_0 as v.
  remember n_0 as n.
  remember x_0 as x.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  assert(X: M0 .[shift a i] = x  \/  M0.[ shift a i] <> x) by tauto.
  elim X.
  {
    intros Y.
    rewrite Q_CountOneHit; auto with zarith.
    symmetry.
    replace (1 + i - L_Count M0 a i v) with (1 + (i - L_Count M0 a i v)) by omega.
    rewrite Q_CountOneHit; auto with zarith.
    {
      rewrite Q_CountRead with (Mint_0 := M0); auto with zarith.
      {
         symmetry.
         rewrite Q_CountRead with (Mint_0 := M0); auto with zarith.

         unfold P_EqualRanges_2_.
         intros.
         rewrite access_update_neq; auto.
         apply separated_1 with (n) (n); auto with zarith.
         apply separated_sym; assumption.
      }
      {
         unfold P_EqualRanges_2_.
         intros.
         rewrite access_update_neq; auto.
         apply shift_injective_neq; auto with zarith.
      }
    }
    rewrite access_update; auto.
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
  }
  {
    intros Y.
    rewrite <- Q_CountOneMiss; auto with zarith.
    {
      symmetry.
      replace (1 + i - L_Count M0 a i v) with (1 + (i - L_Count M0 a i v)) by omega.
      rewrite <- Q_CountOneMiss; auto with zarith.
      {
        rewrite Q_CountRead with (Mint_0 := M0); auto with zarith.
        {
           symmetry.
           rewrite Q_CountRead with (Mint_0 := M0); auto with zarith.

           unfold P_EqualRanges_2_.
           intros.
           rewrite access_update_neq; auto.
           apply separated_1 with (n) (n); auto with zarith.
           apply separated_sym; assumption.
        }
        {
          unfold P_EqualRanges_2_.
          intros.
          rewrite access_update_neq; auto.
          apply shift_injective_neq; auto with zarith.
        }
      }
      rewrite access_update; auto.
    }
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
  }
*)
(* --------------------------------------
  
From 'typed_ref_external_remove_copy_loop_inv_result_preserved_part1': 
  unfold P_EqualRanges_2_ in *.
  intros.

  remember Mint_0 as M.
  remember a_0 as a.
  remember b_0 as b.
  remember i_0 as i.
  remember v_0 as v.
  remember n_0 as n.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  rewrite <- Q_CountOneMiss; auto with zarith.
  {
    symmetry.
    rewrite Q_CountRead with (Mint_0 := M); auto with zarith.

    unfold P_EqualRanges_2_.
    {
      intros.
      rewrite access_update_neq; auto.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.
    }
  }

  rewrite access_update_neq; auto with zarith.
  apply separated_1 with (n) (n); auto with zarith.
  apply separated_sym; assumption.  
*)
Qed.

Goal typed_ref_external_remove_copy_loop_inv_result_preserved_part1.
Hint part-0,preserved,remove_copy,result.
Proof.
  unfold P_EqualRanges_2_ in *.
  intros.

  remember t_1 as M0.
  remember a_1 as A.
  remember a   as B.
  remember i_1 as v.
  remember i_2 as n.

  unfold shift_sint32 in *.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  rewrite <- Q_CountOneMiss; auto with zarith.
  {
    symmetry.
    rewrite Q_CountRead with (t_1 := M0); auto with zarith.

    unfold P_EqualRanges_2_.
    {
      intros.
      rewrite access_update_neq; auto.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.
    }
  }

  rewrite access_update_neq; auto with zarith.
  apply separated_1 with (n) (n); auto with zarith.
  apply separated_sym; assumption.  
Qed.


