(* Generated by Frama-C WP *)

Goal typed_ref_external_lemma_CountBounds.
Hint CountBounds,property.
Proof.
  intros v n M a.
  intros.
  subst x.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    (* base step *)
    rewrite <- Q_CountEmpty; auto with zarith.
  }
  {
    (* induction step *)
    intros.
    replace (Z.succ z) with (1 + z) by omega.
    assert (M.[ shift a z] = v \/ M.[ shift a z] <> v) by tauto.

     elim H3; intros.
     {
        rewrite Q_CountOneHit; auto with zarith.
     }
     {
        rewrite <- Q_CountOneMiss; auto with zarith.
     }
  }
Qed.

Goal typed_ref_external_lemma_CountMonotonic.
Hint CountMonotonic,property.
Proof.
  intros v m n M a.
  intros.
  replace (L_Count M a n v)
    with  ((L_Count M a m v) + (L_Count M (shift a m) (n-m) v)).
  {
     assert(0 <= L_Count M (shift a m) (n - m) v).
     {
        apply Q_CountBounds; auto with zarith.
     }
     omega.
  }
  {
     rewrite <- Q_CountUnion; auto with zarith.
     replace (n-m+m) with n by omega.
     trivial.
  }

Qed.

Goal typed_ref_external_lemma_CountNonegative.
Hint CountNonegative,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_ref_external_lemma_CountUnion.
Hint CountUnion,property.
Proof.
  intros v n k M a.
  intros.
  unfold shift_sint32 in *.
  apply natlike_rec2 with (z := k); auto with zarith.
  {
    assert(X: 0 = L_Count M (shift a n) 0 v).
    {
      rewrite <- Q_CountEmpty; auto with zarith.
    }
    rewrite <- X; auto with zarith.
  }
  {
    intros.
    replace (Z.succ z) with (1 + z) by omega.
    replace (1+z+n) with (1+(z+n)) by omega.
    rewrite Q_CountOne; auto with zarith.
    rewrite H2.
    symmetry.

    rewrite Q_CountOne; auto with zarith.
    unfold shift_sint32.
    replace (shift (shift a n) z) with (shift a (z+n)).
    {
      auto with zarith.
    }
    {
      unfold shift. simpl.
      replace (offset a + (z + n)) with (offset a + n + z) by omega.
      trivial.
    }
  }
Qed.

Goal typed_ref_external_lemma_RemoveCountMonotonic.
Hint RemoveCountMonotonic,property.
Proof.
  unfold L_RemoveCount in *.
  intros v m n M a.
  intros.

  cut(m + (L_Count M a n v) <= n + (L_Count M a m v)).
  {
     omega.
  }
  {
    replace (n) with ((n-m) + m) by omega.
    rewrite Q_CountUnion with (i := n-m); auto with zarith.
    unfold shift_sint32.
    cut (L_Count M (shift a m) (n - m) v <= n - m).
    {
        auto with zarith.
    }
    apply Q_CountBounds; auto with zarith.
  }

Qed.

Goal typed_ref_external_remove_copy_loop_inv_kept_preserved_part1.
Hint kept,part-0,preserved,remove_copy.
Proof.
  unfold P_PreserveCount in *.
  intros.

  remember t_1 as M0.
  remember a_1 as A.
  remember a   as B.
  remember i_2 as v.
  remember i_1 as n.
  remember i0  as x.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  assert(X: M0 .[shift A i] = x  \/  M0.[ shift A i] <> x) by tauto.
  elim X.
  {
    intros Y.
    rewrite A_CountAxiomatic.Q_CountOneHit; auto with zarith.
    symmetry.
    replace (1 + i - A_CountAxiomatic.L_Count M0 a i v) with 
            (1 + (i - A_CountAxiomatic.L_Count M0 a i v)) by omega.
    rewrite A_CountAxiomatic.Q_CountOneHit; auto with zarith.
    {
      rewrite A_CountAxiomatic.Q_CountRead with (t_1 := M0); auto with zarith.
      {
         symmetry.
         rewrite A_CountAxiomatic.Q_CountRead with (t_1 := M0); auto with zarith.

         unfold P_EqualRanges_2_.
         intros.
         rewrite access_update_neq; auto.
         apply separated_1 with (n) (n); auto with zarith.
         apply separated_sym; assumption.
      }
      {
         unfold P_EqualRanges_2_.
         intros.
         rewrite access_update_neq; auto.
         apply shift_injective_neq; auto with zarith.
      }
    }
    rewrite access_update; auto.
    unfold shift_sint32.
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
  }
  {
    intros Y.
    rewrite <- A_CountAxiomatic.Q_CountOneMiss; auto with zarith.
    {
      symmetry.
      replace (1 + i - A_CountAxiomatic.L_Count M0 a i v) 
         with (1 + (i - A_CountAxiomatic.L_Count M0 a i v)) by omega.
      rewrite <- A_CountAxiomatic.Q_CountOneMiss; auto with zarith.
      {
        rewrite A_CountAxiomatic.Q_CountRead with (t_1 := M0); auto with zarith.
        {
           symmetry.
           rewrite A_CountAxiomatic.Q_CountRead with (t_1 := M0); auto with zarith.

           unfold P_EqualRanges_2_.
           intros.
           rewrite access_update_neq; auto.
           apply separated_1 with (n) (n); auto with zarith.
           apply separated_sym; assumption.
        }
        {
          unfold P_EqualRanges_2_.
          intros.
          rewrite access_update_neq; auto.
          apply shift_injective_neq; auto with zarith.
        }
      }
      rewrite access_update; auto.
    }
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
  }
Qed.

Goal typed_ref_external_remove_copy_loop_inv_preserved_preserved_part1.
Hint part-0,preserved,preserved2,remove_copy.
Proof.
  unfold P_PreserveCount in *.
  unfold is_uint32 in *.
  intros.

  remember a_0 as a.
  remember b_0 as b.
  remember n_0 as n.
  remember v_0 as v.
  remember i_0 as i.
  remember Mint_0 as M0.
  remember (M0 .[ shift b (L_RemoveCount M0 a i v) <- M0 .[ shift a i]]) as M1.

  rewrite shift_zero in *.
  rewrite shift_zero in *.


 
  rewrite A_CountAxiomatic.Q_CountRead with (Mint_0 := M0); auto.

  assert(X: M0 .[ shift a i] = x_0 \/ M0 .[ shift a i] <> x_0) by tauto.
  case X.
  + intros equal.

    rewrite A_CountAxiomatic.Q_CountOneHit; auto.
    symmetry.
    rewrite A_CountAxiomatic.Q_CountOneHit; auto.
    symmetry.

    cut(A_CountAxiomatic.L_Count M0 a i x_0 = A_CountAxiomatic.L_Count M1 b (L_RemoveCount M0 a i v) x_0).
      auto with zarith.

    symmetry.
    rewrite A_CountAxiomatic.Q_CountRead with (Mint_0 := M0); auto.
    symmetry.
    apply H26; auto with zarith.

    - unfold P_EqualRanges_2_.
      intros.
      rewrite HeqM1.
      rewrite access_update_neq; auto.
      apply shift_injective_neq; auto with zarith.

   -  intros.
      rewrite HeqM1.
      rewrite access_update; auto.

  + intros not_equal.
    rewrite <- A_CountAxiomatic.Q_CountOneMiss; auto.
    symmetry.
    rewrite <- A_CountAxiomatic.Q_CountOneMiss; auto.
    rewrite A_CountAxiomatic.Q_CountRead with (Mint_0 := M0); auto.
    symmetry.
    apply H26; auto with zarith.

    - unfold P_EqualRanges_2_.
      intros.
      rewrite HeqM1.
      rewrite access_update_neq; auto.
      apply shift_injective_neq; auto with zarith.

    - rewrite HeqM1.
      rewrite access_update; auto.

  + unfold P_EqualRanges_2_.
    intros.
    rewrite HeqM1.
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
Qed.

Goal typed_ref_external_remove_copy_loop_inv_result_preserved_part1.
Hint part-0,preserved,remove_copy,result.
Proof.
  unfold L_RemoveCount in *.
  intros.

  remember t_1 as M.
  remember a_1 as A.
  remember a as B.

  remember i_2 as v.
  remember i_1 as n.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  rewrite <- A_CountAxiomatic.Q_CountOneMiss; auto with zarith.
  {
    symmetry.
    rewrite A_CountAxiomatic.Q_CountRead with (t_1 := M); auto with zarith.

    unfold P_EqualRanges_2_.
    {
      intros.
      rewrite access_update_neq; auto.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.
    }
  }

  rewrite access_update_neq; auto with zarith.
  apply separated_1 with (n) (n); auto with zarith.
  apply separated_sym; assumption.
Qed.

Goal typed_ref_external_remove_copy_loop_inv_stable_preserved_part1.
Hint part-0,preserved,remove_copy,stable.
Proof.
  unfold P_StableRemove in *.
  intros.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  remember i0  as k.
  remember t_1 as M0.
  remember a   as B.
  remember a_1 as A.
  remember i_1 as n.
  remember i_2 as v.

  assert(X: forall m, 0 <= m < n -> shift A m <> shift B (L_RemoveCount M0 A i v)).
  {
    intros.
    apply separated_1 with (n) (n); auto with zarith.
  }
  {
    assert(Xk: shift A k <> shift B (L_RemoveCount M0 A i v)).
    {
      apply X; omega.
    }
    {
      rewrite access_update_neq in *; auto with zarith.
      unfold shift_sint32.
      remember ((M0.[shift B (L_RemoveCount M0 A i v) <- M0.[shift A i]])) as M1.

      assert(Read: (L_RemoveCount M1 A k v) = (L_RemoveCount M0 A k v)). 
      {
         rewrite Q_RemoveCountRead with (t_1 := M0); auto with zarith.
         unfold P_EqualRanges_2_.
         intros.
         rewrite HeqM1.
         rewrite access_update_neq; auto with zarith.
         apply addr_neq_symmetry. 
         apply X; omega.
      }
      {
         case_lt k i.
         { 
           intros.
           rewrite Read.
           rewrite HeqM1.
           rewrite access_update_neq.
           - apply H15; auto with zarith.
           - assert(L_RemoveCount M0 A k v < L_RemoveCount M0 A i v).
             + apply Q_RemoveCountStrictlyMonotonic; auto with zarith.
             + apply shift_injective_neq; omega.
         }
         {
           intros.
           assert(equal: k = i) by omega.
           rewrite equal in *.
           rewrite Read.
           rewrite HeqM1.
           rewrite access_update; auto.
         }
      }
    }
  }
Qed.


