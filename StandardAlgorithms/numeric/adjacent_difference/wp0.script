(* Generated by Frama-C WP *)

Goal typed_ref_external_adjacent_difference_loop_inv_previous_preserved.
Hint adjacent_difference,preserved,previous.
Proof.
   unfold P_PartialSum in *.
   intros.

   unfold shift_sint32 in *.

   remember a_1 as A.
   remember a   as B.
   remember i_1 as n.

   rewrite shift_zero in *.
   rewrite shift_zero in *.

   remember (t_2 .[ shift B i <- (t_2 .[ shift A i]) - (t_2 .[ shift A (i - 1)])]) as X.

   assert(Zero32: is_sint32 0) by (unfold is_sint32; omega).

   case_lt i0 i.
   {
     intros.
     assert(same: X .[ shift A i0] = t_2 .[ shift A i0]).
     {
       rewrite HeqX.
       rewrite access_update_neq; auto with zarith.
       apply separated_1 with (n) (n); auto with zarith.
       apply separated_sym; assumption.
     }
     rewrite same.

     unfold L_Accumulate_2_ in *.
     (* rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith. *)
     {
       assert(A_AccumulateAxiomatic.L_Accumulate_1_ X   B (1 + i0) 0 =
              A_AccumulateAxiomatic.L_Accumulate_1_ t_2 B (1 + i0) 0).
       {
         rewrite <- A_AccumulateAxiomatic.Q_AccumulateRead with (t := X) (t_1 := t_2); auto with zarith.
         {
           unfold P_EqualRanges_2_.
           intros.
           rewrite HeqX.
           unfold shift_sint32.
           rewrite access_update_neq; auto with zarith.
           apply shift_injective_neq; omega.
         }
       }

       rewrite H30.
       apply H11; auto with zarith.
     } 
   }
   {
     intros.
     assert(equal: i0 = i) by omega.
     rewrite equal in *.
     
     assert(X1: X.[shift A i] = t_2.[shift A i]).
     {
       rewrite HeqX.
       rewrite access_update_neq; auto.
       apply separated_1 with (n) (n); auto with zarith.
       apply separated_sym; assumption.
     }
     rewrite X1.

     unfold L_Accumulate_2_ in *.
     rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
     {
        unfold shift_sint32.

        assert(F: A_AccumulateAxiomatic.L_Accumulate_1_ X B i 0 =
                  A_AccumulateAxiomatic.L_Accumulate_1_ t_2 B i 0).
        {     
          rewrite <- A_AccumulateAxiomatic.Q_AccumulateRead with (t := X) (t_1 := t_2); auto with zarith.
          {
            unfold P_EqualRanges_2_.
            intros.
            rewrite HeqX.
            unfold shift_sint32.
            rewrite access_update_neq; auto with zarith.
            apply shift_injective_neq; omega.
          }
        }
        rewrite F.
        rewrite HeqX.
        rewrite access_update.

        replace (i) with (1 + (i-1)) by omega.
        rewrite <- H11; auto with zarith.
        replace (1 + (i - 1)) with (i) by omega.
        omega.
     }
   }
Qed.

Goal typed_ref_external_lemma_Accumulate_1.
Hint Accumulate_1,property.
Proof.
(* auto with zarith. *)
Qed.


