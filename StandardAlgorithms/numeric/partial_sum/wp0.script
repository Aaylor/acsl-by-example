(* Generated by Frama-C WP *)

Goal typed_ref_external_lemma_Accumulate_1.
Hint Accumulate_1,property.
Proof.
  intros.
  unfold L_Accumulate_2_.
  replace 1 with (1+0) by omega.
  rewrite A_AccumulateAxiomatic.Q_AccumulateNext.
  replace (L_Accumulate_1_ t a 0 0) with 0; auto with zarith.
  rewrite <- A_AccumulateAxiomatic.Q_AccumulateEmpty; auto with zarith.
  unfold Cint.is_sint32; omega.
  unfold Cint.is_sint32; omega.
Qed.

Goal typed_ref_external_partial_sum_assert.
Hint partial_sum,property.
Proof.
(* --------------------------------------
  
From 'typed_ref_external_partial_sum_assert_4': 
   unfold L_Accumulate_2_ in *.
   intros.
   unfold shift_sint32 in *.

   remember a   as B.
   remember a_1 as A.
   remember i_2 as n.

   assert(X: t_2 .[ shift A i_1] = t_1 .[ shift A i_1]).
     rewrite <- H11; auto with zarith.
   rewrite X.
   rewrite <- H19.
   rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
   unfold is_sint32; omega.
*)
(* --------------------------------------
  
From 'typed_ref_external_partial_sum_assert_post': 
   unfold L_Accumulate_2_ in *.
   intros.
   unfold shift_sint32 in *.

   remember a   as B.
   remember a_1 as A.
   remember i_2 as n.

   assert(X: t_2 .[ shift A i_1] = t_1 .[ shift A i_1]).
     rewrite <- H12; auto with zarith.
   rewrite X.
   rewrite <- H20.
   rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
   unfold is_sint32; omega.
*)
(* --------------------------------------
  
From 'typed_ref_external_partial_sum_assert_bound_part1': 
  unfold L_Accumulate_2_ in *.
  unfold is_sint32 in *.
  unfold shift_sint32 in *.
  intros.

  remember i_2 as n.
  remember a_1 as A.
  remember a   as B.

  rewrite <- H18.
  (* rewrite Zplus_comm. *)
  rewrite <- H12; auto with zarith.
  rewrite <- A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
  unfold is_sint32; omega.
*)
Qed.

Goal typed_ref_external_partial_sum_assert_4.
Hint partial_sum,property.
Proof.
   unfold L_Accumulate_2_ in *.
   intros.
   unfold shift_sint32 in *.

   remember a   as B.
   remember a_1 as A.
   remember i_2 as n.

   assert(X: t_2 .[ shift A i_1] = t_1 .[ shift A i_1]).
     rewrite <- H11; auto with zarith.
   rewrite X.
   rewrite <- H19.
   rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
   unfold is_sint32; omega.
Qed.

Goal typed_ref_external_partial_sum_assert_5.
Hint partial_sum,property.
Proof.
   unfold L_Accumulate_2_ in *.
   intros.
   unfold shift_sint32 in *.

   remember a   as B.
   remember a_1 as A.
   remember i_2 as n.

   assert(X: t_2 .[ shift A i_1] = t_1 .[ shift A i_1]).
     rewrite <- H12; auto with zarith.
   rewrite X.
   rewrite <- H20.
   rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
   unfold is_sint32; omega.
Qed.

Goal typed_ref_external_partial_sum_assert_bound_part1.
Hint bound,part-0,partial_sum,property.
Proof.
  unfold L_Accumulate_2_ in *.
  unfold is_sint32 in *.
  unfold shift_sint32 in *.
  intros.

  remember i_2 as n.
  remember a_1 as A.
  remember a   as B.

  rewrite <- H18.
  (* rewrite Zplus_comm. *)
  rewrite <- H12; auto with zarith.
  rewrite <- A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
  unfold is_sint32; omega.
Qed.

Goal typed_ref_external_partial_sum_assert_bound_part2.
Hint bound,part-1,partial_sum,property.
Proof.
  unfold L_Accumulate_2_ in *.
  unfold is_sint32 in *.
  unfold shift_sint32 in *.
  intros.

  remember i_2 as n.
  remember a_1 as A.
  remember a   as B.

  rewrite <- H18.
  (* rewrite Zplus_comm. *)
  rewrite <- H12; auto with zarith.
  rewrite <- A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
  unfold is_sint32; omega.
Qed.

Goal typed_ref_external_partial_sum_assert_post.
Hint partial_sum,post,property.
Proof.
   unfold L_Accumulate_2_ in *.
   intros.
   unfold shift_sint32 in *.

   remember a   as B.
   remember a_1 as A.
   remember i_2 as n.

   assert(X: t_2 .[ shift A i_1] = t_1 .[ shift A i_1]).
     rewrite <- H12; auto with zarith.
   rewrite X.
   rewrite <- H20.
   rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
   unfold is_sint32; omega.
Qed.

Goal typed_ref_external_partial_sum_loop_inv_bound1_preserved_part1.
Hint bound1,part-0,partial_sum,preserved.
Proof.
  unfold P_PartialSum in *.
  intros.
  unfold shift_sint32 in *.

  remember a_1 as A.
  remember a   as B.
  remember i_2 as n.

  replace (2+i_1) with (1+(1+i_1)) by omega.
  apply H46; auto with zarith.

Qed.

Goal typed_ref_external_partial_sum_loop_inv_bound_established_part1.
Hint bound,established,part-0,partial_sum.
Proof.
  unfold is_sint32 in *.
  intros.
  unfold shift_sint32 in *.
  rewrite shift_zero in *.
  rewrite shift_zero in *.

  remember i as n.
  remember a_1 as A.
  remember a   as B.

  rewrite access_update_neq.
Qed.

Goal typed_ref_external_partial_sum_loop_inv_pre_established.
Hint established,partial_sum,pre.
Proof.
(* --------------------------------------
  
From 'typed_ref_external_partial_sum_loop_inv_x_established': 
  unfold is_sint32 in *.
  intros.
  unfold shift_sint32 in *.
  rewrite shift_zero in *.
  rewrite shift_zero in *.

  remember i_1 as n.
  remember a_1 as A.
  remember a   as B.

  rewrite access_update_neq.

*)
(* --------------------------------------
  
From 'typed_ref_external_partial_sum_loop_inv_bound_established_part1': 
  unfold is_sint32 in *.
  intros.
  unfold shift_sint32 in *.
  rewrite shift_zero in *.
  rewrite shift_zero in *.

  remember i as n.
  remember a_1 as A.
  remember a   as B.

  rewrite access_update_neq.
*)
Qed.

Goal typed_ref_external_partial_sum_loop_inv_previous_preserved.
Hint partial_sum,preserved,previous.
Proof.
  unfold P_PartialSum in *.
  intros.
  unfold shift_sint32 in *.

  remember a_1 as A.
  remember a   as B.
  remember i0 as k.
  remember i_1 as n.

  unfold P_EqualRanges_1_ in *.
  unfold shift_sint32 in *.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  assert(Zero32: is_sint32 0) by (unfold is_sint32; omega).

  remember (t_2 .[ shift B i <- (t_2 .[ shift A i]) + (t_2 .[ shift B (i - 1)])]) as X.

  case_lt k i.
  {
    intros.
    assert(x1: X.[shift B k] = t_2.[shift B k]).
    {
      rewrite HeqX.
      rewrite access_update_neq; auto.
      apply shift_injective_neq; omega.
    }
    rewrite x1.

    unfold L_Accumulate_2_.
    assert(x2: A_AccumulateAxiomatic.L_Accumulate_1_ X A (1 + k) 0 = 
               A_AccumulateAxiomatic.L_Accumulate_1_ t_2 A (1 + k) 0).
    {
      rewrite <- A_AccumulateAxiomatic.Q_AccumulateRead with (t := X) (t_1 := t_2); auto with zarith.
      unfold P_EqualRanges_2_.
      intros.
      rewrite HeqX.
      unfold shift_sint32.
      rewrite access_update_neq; auto with zarith.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.
    }

    rewrite x2.
    apply H10; omega.
  }
  {
    intros.
    replace k with i in * by omega.
    unfold L_Accumulate_2_ in *.
    rewrite A_AccumulateAxiomatic.Q_AccumulateNext; auto with zarith.
    unfold shift_sint32.

    rewrite HeqX.
    rewrite access_update.
    rewrite access_update_neq.
    {
      rewrite <- HeqX.

      assert(x2: A_AccumulateAxiomatic.L_Accumulate_1_ X   A i 0 = 
                 A_AccumulateAxiomatic.L_Accumulate_1_ t_2 A i 0).
      {
        rewrite <- A_AccumulateAxiomatic.Q_AccumulateRead with (t := X) (t_1 := t_2); auto with zarith.
        unfold P_EqualRanges_2_.
        intros.
        rewrite HeqX.
        unfold shift_sint32.
        rewrite access_update_neq; auto with zarith.
        apply separated_1 with (n) (n); auto with zarith.
        apply separated_sym; assumption.
      }

      rewrite x2.  
      replace (i) with (1 + (i-1)) by omega.   
      rewrite <- H10; auto with zarith.
      replace (1 + (i - 1)) with i by omega.
      trivial.
    }
    {
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.
    }
  }

Qed.

Goal typed_ref_external_partial_sum_loop_inv_x_established.
Hint established,partial_sum,x.
Proof.
  unfold is_sint32 in *.
  intros.
  unfold shift_sint32 in *.
  rewrite shift_zero in *.
  rewrite shift_zero in *.

  remember i_1 as n.
  remember a_1 as A.
  remember a   as B.

  rewrite access_update_neq.

Qed.


