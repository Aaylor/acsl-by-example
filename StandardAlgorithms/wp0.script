(* Generated by Frama-C WP *)

Goal typed_ref_external_lemma_AdjacentDifferenceInverse.
Hint AdjacentDifferenceInverse,property.
Proof.
  intros n L K A B H.

  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros.
    unfold P_Unchanged_2_ in *.
    unfold P_Unchanged_1_ in *.
    intros.
    intuition.
  }
  {
    intros.
    Require Import Psatz.
    replace (Z.succ z) with (1+z) in * by lia.

    assert(X: P_Unchanged_2_ L K A z). {
      apply H1; auto with zarith.
      - apply Q_UnchangedSection with (i := 1+z); auto with zarith.
      - apply Q_PartialSumSection with (i := 1+z); auto with zarith.
      - apply Q_AdjacentDifferenceSection with (i := 1+z); auto with zarith.
    } 

    unfold P_Unchanged_2_.
    unfold P_Unchanged_1_.
    intros.

    assert(Y: i < z \/ i = z) by lia.
    destruct Y as [less|equal].
    {
      apply X; auto with zarith.
    }
    {
      rewrite equal.
      rewrite H3; auto with zarith.
      rewrite Q_AccumulateDefaultNext; auto with zarith.
      rewrite H2; auto with zarith.
      rewrite <- H4; auto with zarith.

      assert (Z: z = 0 \/ z > 0) by lia.
      destruct Z as [zero|pos].
      {
        rewrite zero.
        rewrite Q_DifferenceEmptyOrSingle; auto with zarith.
        rewrite <- Q_AccumulateDefault0; lia.
      }
      {
        rewrite Q_DifferenceNext; auto with zarith.
        cut ((K .[ shift_sint32 A (z - 1)]) = L_Accumulate_2_ L B z).
        - lia.
        - rewrite <- X; auto with zarith.
          rewrite H3; auto with zarith.
          replace (1 + (z-1)) with z by lia.
          trivial.
      }
    }
  }





























Qed.

Goal typed_ref_external_lemma_CountBounds.
Hint CountBounds,property.
Proof.
  Require Import Psatz.
  intros v n M a.
  intros.
  subst x.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    (* base step *)
    rewrite <- Q_CountEmpty; auto with zarith.
  }
  {
    (* induction step *)
    intros.
    replace (Z.succ z) with (1 + z) by lia.
    assert (X: M.[ shift a z] = v \/ M.[ shift a z] <> v) by tauto.

    elim X; intros.
    - rewrite Q_CountOneHit; auto with zarith.
    - rewrite <- Q_CountOneMiss; auto with zarith.
  }





























Qed.

Goal typed_ref_external_lemma_CountSectionBounds.
Hint CountSectionBounds,property.
Proof.
  Require Import Psatz.
  intros.
  subst x.
  remember i_1 as m.
  remember i   as n.
  remember i_2 as v.
 
  replace n with (m + (n-m)) by lia.
  apply natlike_rec2 with (z := (n - m)); auto with zarith.
  {
    rewrite Zplus_0_r.
    rewrite <- Q_CountSectionEmpty; auto with zarith.
  }
  {
    intros.
    replace (m + Z.succ z) with (1 + (m+z)) by lia.

    assert (X: t.[ shift a (m+z)] =  v \/
               t.[ shift a (m+z)] <> v) by lia.
    destruct X as [eq|neq]. 
    - rewrite Q_CountSectionHit; auto with zarith.
    - rewrite <- Q_CountSectionMiss; auto with zarith.
  }





























Qed.

Goal typed_ref_external_lemma_CountSectionMonotonic.
Hint CountSectionMonotonic,property.
Proof.
  Require Import Psatz.
  intros.
  remember i_3 as v.
  remember i_2 as m.
  remember i   as p.
  remember i_1 as n.

  replace p with (n + (p-n)) by lia.
  apply natlike_rec2 with (z := (p - n)); auto with zarith.
  {
    replace (n+0) with n by lia.
    lia.
  }
  {
    intros.
    replace (n + Z.succ z) with (1 + (n+z)) by lia.

    assert (X: t.[ shift a (n+z)] =  v \/
               t.[ shift a (n+z)] <> v) by lia.
    destruct X as [eq|neq].
    - rewrite Q_CountSectionHit; auto with zarith.
    - rewrite <- Q_CountSectionMiss; auto with zarith.

  }





























Qed.

Goal typed_ref_external_lemma_CountSectionUnion.
Hint CountSectionUnion,property.
Proof.
  Require Import Psatz.
  intros.
  remember i_2 as v.
  remember i   as n.
  remember i_1 as m.

  replace n with (m + (n-m)) by lia.
  apply natlike_rec2 with (z := (n - m)); auto with zarith.
  {
    rewrite Zplus_0_r.
    replace (L_CountSection t a m m v) with 0 by (rewrite <- Q_CountSectionEmpty; auto with zarith).
    lia.
  }
  {
    intros.
    replace (m + Z.succ z) with (1 + (m+z)) by lia.

    assert (X: t.[ shift a (m+z)] =  v \/ t.[ shift a (m+z)] <> v) by lia.
    destruct X as [eq|neq].
    {
      rewrite Q_CountSectionHit; auto with zarith.
      rewrite H3; auto with zarith.
      symmetry.
      rewrite Q_CountSectionHit; auto with zarith.
    }
    {
      rewrite <- Q_CountSectionMiss; auto with zarith.
      symmetry.
      rewrite <- Q_CountSectionMiss; auto with zarith.
    }
  }





























Qed.

Goal typed_ref_external_lemma_HeapMaximum.
Hint HeapMaximum,property.
Proof.
  Require Import Psatz.
  intros.

  (* for me it somehow easier to first proof this slight reformulation and apply it later *)
  assert(Reformulate: 
           forall (i : int) (s : farray addr int) (b : addr),
           let x := 1 + i in 0 <= i -> P_IsHeap s b x -> P_MaxElement s b x 0).
  {
    intros n s b.
    intros x A.
    subst x.
    apply natlike_rec2 with (z := n); auto with zarith.
    {
      rewrite Zplus_0_r.
      intros.
      unfold P_MaxElement.
      split; auto with zarith.
      split; auto with zarith.
      unfold P_UpperBound.
      intros.
      replace i0 with 0 by lia.
      lia.
    }
    {
      intros z.
      intros.
      replace (Z.succ z) with (1+z) in * by lia.

       assert(X: P_IsHeap s b (1+z)).
       {
         unfold P_IsHeap.
         intros.
         apply H3; auto with zarith.
       }
       assert(Y: P_MaxElement s b (1+z) 0).
       {
        apply H2; auto with zarith.
       }
       unfold P_MaxElement.
       unfold P_UpperBound.
       split; auto with zarith.
       split; auto with zarith.
       intros.

       assert(less_equal: i0 < 1+z \/ i0 = 1+z) by lia.
       destruct less_equal as [less|equal].
       {
         apply Y; auto with zarith.
       }
       {
         rewrite equal.
         assert(Z: s .[ shift_sint32 b (1+z)] <= s .[ shift_sint32 b (L_HeapParent (1+z))]).
         {
           apply H3; auto with zarith.
         }
         assert(ZZ: s .[ shift_sint32 b (L_HeapParent (1+z))] <= s .[ shift_sint32 b 0]).
         {
           unfold L_HeapParent.
           replace (1+z-1) with z by lia.
           apply Y; auto with zarith.
           cut (Cdiv z 2 <= z); auto with zarith.
           apply Q_HeapBounds; lia.
           apply Q_HeapBounds; lia.
         }
         lia.
       }
     }
  }

  replace i with (1+(i-1)) by lia.
  apply Reformulate; auto with zarith.
  replace (1+(i-1)) with i by lia.
  trivial.





























Qed.

Goal typed_ref_external_lemma_LowerBoundShift.
Hint LowerBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_LowerBound.
  intros val b c d L a H0 LowerBound i X Y.
  replace i with (b + (i - b)); auto with zarith.
  rewrite <- shift_associative.
  apply LowerBound; lia.





























Qed.

Goal typed_ref_external_lemma_MultisetUnchangedUnion.
Hint MultisetUnchangedUnion,property.
Proof.
  unfold P_MultisetUnchanged_1_ in *.
  intros.
  remember i0 as v.
  remember i as n.
  remember i_1 as k.

  rewrite Q_CountSectionUnion with (i_1 := k); auto with zarith.
  symmetry.
  rewrite Q_CountSectionUnion with (i_1 := k); auto with zarith.
  rewrite H1; auto with zarith.
  rewrite H2; auto with zarith.





























Qed.

Goal typed_ref_external_lemma_RemoveCountMonotonic.
Hint RemoveCountMonotonic,property.
Proof.
  Require Import Psatz.
  unfold L_RemoveCount in *.
  intros v m n M a.
  intros.

  cut(m + (L_Count M a n v) <= n + (L_Count M a m v)); auto with zarith.
  rewrite Q_CountUnion with (i_1 := m); auto with zarith.
  unfold L_Count.
  cut (m + L_CountSection M a m n v <= n); auto with zarith.
  apply Q_CountSectionBounds; auto with zarith.





























Qed.

Goal typed_ref_external_lemma_RetainAllButOneMiss.
Hint RetainAllButOneMiss,property.
Proof.
  Require Import Psatz.
  intros.

  remember a_1 as A.
  remember a   as B.
  remember i_2 as v.
  remember i_1 as m.
  remember i   as n.
  remember t   as K.
  remember t_1 as L.

  subst x a_2.
  unfold P_RetainAllButOne in *.
  intros x. intros.

  assert(X: x =  L .[ shift_sint32 A m] \/ x <> L .[ shift_sint32 A m]) by lia.

  destruct X as [eq|neq].
  {
    rewrite Q_CountOneHit; auto with zarith.
    rewrite <- Q_CountRead with (t := K); auto with zarith.
    - symmetry.
      rewrite Q_CountOneHit; auto with zarith.
      rewrite <- Q_CountRead with (t := K); auto with zarith.
      rewrite <- H5; auto with zarith.
    - apply Q_UnchangedSection with (i := 1+m); auto with zarith.
  }
  {
    rewrite <- Q_CountOneMiss; auto with zarith.
    rewrite <- Q_CountRead with (t := K); auto with zarith.
    - symmetry.
      rewrite <- Q_CountOneMiss; auto with zarith.
      rewrite <- Q_CountRead with (t := K); auto with zarith.
      rewrite H5; auto with zarith.
    - apply Q_UnchangedSection with (i := 1+m); auto with zarith.
  }





























Qed.

Goal typed_ref_external_lemma_SortedShift.
Hint SortedShift,property.
Proof.
  Require Import Psatz.
  unfold P_Sorted_2_.
  unfold P_Sorted_1_ in *.
  unfold shift_sint32 in *.
  intros l r L a.
  intros.

  rewrite shift_associative.
  rewrite shift_associative.
  apply H1; lia.





























Qed.

Goal typed_ref_external_lemma_StrictLowerBoundShift.
Hint StrictLowerBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_StrictLowerBound in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_2 + (i0 - i_2)) by lia.
  rewrite <- shift_associative.
  apply H0; lia.





























Qed.

Goal typed_ref_external_lemma_StrictUpperBoundShift.
Hint StrictUpperBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_StrictUpperBound in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_1 + (i0 - i_1)) by lia.
  rewrite <- shift_associative.
  apply H0; lia.





























Qed.

Goal typed_ref_external_lemma_UpperBoundShift.
Hint UpperBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_UpperBound in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_1 + (i0 - i_1)) by lia.
  rewrite <- shift_associative.
  apply H0; auto with zarith.





























Qed.

Goal typed_ref_external_remove_copy_assert_retain.
Hint property,remove_copy,retain.
Proof.
  intros.
  apply Q_MultisetRetainRestMiss.





























Qed.

Goal typed_ref_external_remove_copy_assert_retain_2.
Hint property,remove_copy,retain.
Proof.
  intros.
  remember (t_1 .[ a_5 <- x]) as M.

  subst x_1.
  remember (L_RemoveCount t_2 a_1 i_2 i) as j.
  rewrite H14.
  (* replace x_1 with (1 + (x_1 -1)) by auto with zarith. *)
  (* replace x_2 with (1 + (x_2 -1)) by auto with zarith. *)
  apply Q_MultisetRetainRestMiss with (t_1); auto with zarith.





























Qed.

Goal typed_ref_external_remove_copy_core_active_post_retain_2.
Hint active,property,remove_copy_core,retain.
Proof.
(* auto with zarith. *)





























Qed.

Goal typed_ref_lemma_AdjacentDifferenceInverse.
Hint AdjacentDifferenceInverse,property.
Proof.
  intros n L K A B H.

  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros.
    unfold P_Unchanged_2_ in *.
    unfold P_Unchanged_1_ in *.
    intros.
    intuition.
  }
  {
    intros.
    Require Import Psatz.
    replace (Z.succ z) with (1+z) in * by lia.

    assert(X: P_Unchanged_2_ L K A z). {
      apply H1; auto with zarith.
      - apply Q_UnchangedSection with (i := 1+z); auto with zarith.
      - apply Q_PartialSumSection with (i := 1+z); auto with zarith.
      - apply Q_AdjacentDifferenceSection with (i := 1+z); auto with zarith.
    } 

    unfold P_Unchanged_2_.
    unfold P_Unchanged_1_.
    intros.

    assert(Y: i < z \/ i = z) by lia.
    destruct Y as [less|equal].
    {
      apply X; auto with zarith.
    }
    {
      rewrite equal.
      rewrite H3; auto with zarith.
      rewrite Q_AccumulateDefaultNext; auto with zarith.
      rewrite H2; auto with zarith.
      rewrite <- H4; auto with zarith.

      assert (Z: z = 0 \/ z > 0) by lia.
      destruct Z as [zero|pos].
      {
        rewrite zero.
        rewrite Q_DifferenceEmptyOrSingle; auto with zarith.
        rewrite <- Q_AccumulateDefault0; lia.
      }
      {
        rewrite Q_DifferenceNext; auto with zarith.
        cut ((K .[ shift_sint32 A (z - 1)]) = L_Accumulate_2_ L B z).
        - lia.
        - rewrite <- X; auto with zarith.
          rewrite H3; auto with zarith.
          replace (1 + (z-1)) with z by lia.
          trivial.
      }
    }
  }





























Qed.

Goal typed_ref_lemma_CountSectionBounds.
Hint CountSectionBounds,property.
Proof.
  Require Import Psatz.
  intros.
  subst x.
  remember i_1 as m.
  remember i   as n.
  remember i_2 as v.
 
  replace n with (m + (n-m)) by lia.
  apply natlike_rec2 with (z := (n - m)); auto with zarith.
  {
    rewrite Zplus_0_r.
    rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.
  }
  {
    intros.
    replace (m + Z.succ z) with (1 + (m+z)) by lia.

    assert (X: t.[ shift a (m+z)] =  v \/
               t.[ shift a (m+z)] <> v) by lia.
    destruct X as [eq|neq]. 
    - rewrite A_Count.Q_CountSectionHit; auto with zarith.
    - rewrite <- A_Count.Q_CountSectionMiss; auto with zarith.
  }






















Qed.

Goal typed_ref_lemma_CountSectionMonotonic.
Hint CountSectionMonotonic,property.
Proof.
  Require Import Psatz.
  intros.
  remember i_3 as v.
  remember i_2 as m.
  remember i   as p.
  remember i_1 as n.

  replace p with (n + (p-n)) by lia.
  apply natlike_rec2 with (z := (p - n)); auto with zarith.
  {
    replace (n+0) with n by lia.
    lia.
  }
  {
    intros.
    replace (n + Z.succ z) with (1 + (n+z)) by lia.

    assert (X: t.[ shift a (n+z)] =  v \/
               t.[ shift a (n+z)] <> v) by lia.
    destruct X as [eq|neq].
    - rewrite A_Count.Q_CountSectionHit; auto with zarith.
    - rewrite <- A_Count.Q_CountSectionMiss; auto with zarith.

  }






















Qed.

Goal typed_ref_lemma_CountSectionUnion.
Hint CountSectionUnion,property.
Proof.
  Require Import Psatz.
  intros.
  remember i_2 as v.
  remember i   as n.
  remember i_1 as m.

  replace n with (m + (n-m)) by lia.
  apply natlike_rec2 with (z := (n - m)); auto with zarith.
  {
    rewrite Zplus_0_r.
    replace (L_Count_1_ t a m m v) with 0 by (rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith).
    lia.
  }
  {
    intros.
    replace (m + Z.succ z) with (1 + (m+z)) by lia.

    assert (X: t.[ shift a (m+z)] =  v \/ t.[ shift a (m+z)] <> v) by lia.
    destruct X as [eq|neq].
    {
      rewrite A_Count.Q_CountSectionHit; auto with zarith.
      rewrite H3; auto with zarith.
      symmetry.
      rewrite A_Count.Q_CountSectionHit; auto with zarith.
    }
    {
      rewrite <- A_Count.Q_CountSectionMiss; auto with zarith.
      symmetry.
      rewrite <- A_Count.Q_CountSectionMiss; auto with zarith.
    }
  }



























Qed.

Goal typed_ref_lemma_CountShift.
Hint CountShift,property.
Proof.
  Require Import Psatz.
  intros v m n t a.
  intros.
  unfold shift_sint32.

  apply natlike_rec2 with (z := n); auto with zarith.
  {
    replace (0 + m) with m by lia.
    rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.
    rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.
  }
  {
    assert(Shift: forall p k l, 
            (shift (shift p k) l) = (shift p (l + k))).
    {
      intros.
      unfold shift.
      simpl.
      replace (offset p + k + l) with (offset p + (l + k)) by lia.
      trivial.
    }
    
    
    intros.
    replace (Z.succ z) with (1 + z) by auto with zarith.
    rewrite Q_CountSectionOne; auto with zarith.
    replace (1 + z + m) with (1 + (z + m)) by lia.
 
    rewrite Q_CountSectionOne; auto with zarith.

    cut(L_Count_1_ t a (z + m) (1 + (z + m)) v = 
        L_Count_1_ t (shift a m) z (1 + z) v).
    {
      auto with zarith.
    }
    {
       pose (azm := t.[shift a (z + m)]).
       assert (X: azm = v \/ azm <> v) by tauto.
       destruct X as [eq|neq].
       {
         rewrite A_Count.Q_CountSectionHit; auto with zarith.
         rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.
         rewrite A_Count.Q_CountSectionHit; auto with zarith.
         {
           rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.
         }
         {
           subst azm.
           unfold shift_sint32.
           rewrite Shift.
           auto.
         }
       }
       {
         rewrite <- A_Count.Q_CountSectionMiss; auto with zarith.
         rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.
         rewrite <- A_Count.Q_CountSectionMiss; auto with zarith.
         {
           rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.
         }
         {
           subst azm.
           unfold shift_sint32.
           rewrite Shift.
           auto.
         }
       }
       
    }
  }























Qed.

Goal typed_ref_lemma_HasValueCountInversion.
Hint HasValueCountInversion,property.
Proof.
  Require Import Psatz.
  intros v m n t a.
  intros V.

  assert(X: n < m \/ n >= m) by tauto.

  destruct X as [le|geq].
  {
    intros.
    rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.   
  }
  {
    pose (p := n - m).
    assert (p >= 0). {
      subst p.
      lia.
    }

    replace n with (m + p).

    apply natlike_rec2 with (z := p); auto with zarith.
    {
       replace (m + 0) with m by lia.
       intros.
       rewrite <- A_Count.Q_CountSectionEmpty; auto with zarith.   
    }
    {
      intros.
      replace (Z.succ z) with (1 + z) in * by lia.
      replace (m + (1 + z)) with (1 + (m + z)) in * by lia.

      rewrite <- A_Count.Q_CountSectionMiss; auto with zarith.
      apply H1.
      {
        unfold P_HasValue_1_ in *.
        intuition.
        apply H2.
        destruct H3.
        exists x; auto with zarith.
      }
      {
        unfold P_HasValue_1_ in *.
        intuition.
        apply H2.
        exists (m + z); auto with zarith.
      }
    }
    {
       subst p; lia.
    }
  }
























Qed.

Goal typed_ref_lemma_HasValueShiftInversion.
Hint HasValueShiftInversion,property.
Proof.
  Require Import Psatz.
  intros v m n.
  intros.
  unfold P_HasValue_1_ in *.
  unfold shift_sint32 in *.

  assert(Shift: forall p k l,
            (shift (shift p k) l) = (shift p (l + k))).
  {
    intros.
    unfold shift.
    simpl.
    replace (offset p + k + l) with (offset p + (l + k)) by lia.
    trivial.
  }

  destruct H0 as [j [K L]].
  pose (k := j - m).
  assert (0 <= k < n) by (subst k; lia).

  replace j with (k + m) in K by (subst k; lia).
  rewrite <- Shift in K.
  exists k.
  split; auto.



























Qed.

Goal typed_ref_lemma_HeapBounds.
Hint HeapBounds,property.
Proof.
(* auto with zarith. *)
















Qed.

Goal typed_ref_lemma_HeapMaximum.
Hint HeapMaximum,property.
Proof.
  Require Import Psatz.
  intros.

  (* for me it somehow easier to first proof this slight reformulation and apply it later *)
  assert(Reformulate: 
           forall (i : int) (s : farray addr int) (b : addr),
           let x := 1 + i in 0 <= i -> P_IsHeap s b x -> P_MaxElement s b x 0).
  {
    intros n s b.
    intros x A.
    subst x.
    apply natlike_rec2 with (z := n); auto with zarith.
    {
      rewrite Zplus_0_r.
      intros.
      unfold P_MaxElement.
      split; auto with zarith.
      split; auto with zarith.
      unfold P_UpperBound.
      intros.
      replace i0 with 0 by lia.
      lia.
    }
    {
      intros z.
      intros.
      replace (Z.succ z) with (1+z) in * by lia.

       assert(X: P_IsHeap s b (1+z)).
       {
         unfold P_IsHeap.
         intros.
         apply H3; auto with zarith.
       }
       assert(Y: P_MaxElement s b (1+z) 0).
       {
        apply H2; auto with zarith.
       }
       unfold P_MaxElement.
       unfold P_UpperBound.
       split; auto with zarith.
       split; auto with zarith.
       intros.

       assert(less_equal: i0 < 1+z \/ i0 = 1+z) by lia.
       destruct less_equal as [less|equal].
       {
         apply Y; auto with zarith.
       }
       {
         rewrite equal.
         assert(Z: s .[ shift_sint32 b (1+z)] <= s .[ shift_sint32 b (L_HeapParent (1+z))]).
         {
           apply H3; auto with zarith.
         }
         assert(ZZ: s .[ shift_sint32 b (L_HeapParent (1+z))] <= s .[ shift_sint32 b 0]).
         {
            (* jg: somehow Frama-C/Why/Coq cannot find the ACSL lemma HeapBounds ...
                   so I have to do a clumsy proof by hand *)
            assert (HeapBoundsBug: forall k, let x := ((Cdiv k 2))%Z in
                       ((0 <= k)%Z) -> (((x <= k)%Z) /\ ((0 <= x)%Z))).
            {
              intros.
              subst x.
              replace (Cdiv k 2) with (k/2).
              {
                split.
                - assert(OR: 0 < k \/ 0 = k) by (apply Zle_lt_or_eq; lia).
                  destruct OR as [less | zero].
                  + cut (k/2 < k).
                    ++ auto with zarith.
                    ++ apply Z_div_lt; lia.
                  + rewrite <- zero.
                    auto with zarith.  
                - apply Z_div_pos; lia.
              }
              {
                symmetry.
                apply Cdiv_cases; lia.
              }
            }

           unfold L_HeapParent.
           replace (1+z-1) with z by lia.
           apply Y; auto with zarith.
           - apply HeapBoundsBug; lia. (* here Q_HeapBounds should be visibile but it isn't *)
           - cut (Cdiv z 2 <= z); auto with zarith.
             apply HeapBoundsBug; lia. (* here Q_HeapBounds should be visibile but it isn't *)
         }
         lia.
       }
     }
  }

  replace i with (1+(i-1)) by lia.
  apply Reformulate; auto with zarith.
  replace (1+(i-1)) with i by lia.
  trivial.
















Qed.

Goal typed_ref_lemma_LowerBoundShift.
Hint LowerBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_LowerBound.
  intros val b c d L a H0 LowerBound i X Y.
  replace i with (b + (i - b)); auto with zarith.

  assert(Assoc: forall q m n, shift (shift q m) n = shift q (m+n)).
  {
    intros.
    unfold shift.
    simpl.
    auto with zarith.
    replace (offset q + m + n) with (offset q + (m + n)) by lia.
    trivial.
  }
  rewrite <- Assoc.
  apply LowerBound; lia.





























Qed.

Goal typed_ref_lemma_MultisetUnchangedUnion.
Hint MultisetUnchangedUnion,property.
Proof.
  unfold P_MultisetUnchanged_1_ in *.
  intros.
  remember i0 as v.
  remember i as n.
  remember i_1 as k.

  rewrite Q_CountSectionUnion with (i_1 := k); auto with zarith.
  symmetry.
  rewrite Q_CountSectionUnion with (i_1 := k); auto with zarith.
  rewrite H1; auto with zarith.
  rewrite H2; auto with zarith.





























Qed.

Goal typed_ref_lemma_RemoveCountMonotonic.
Hint RemoveCountMonotonic,property.
Proof.
  Require Import Psatz.
  unfold L_RemoveCount in *.
  intros v m n M a.
  intros.

  cut(m + (L_Count_2_ M a n v) <= n + (L_Count_2_ M a m v)); auto with zarith.
  rewrite Q_CountUnion with (i_1 := m); auto with zarith.
  unfold L_Count_2_.
  cut (m + L_Count_1_ M a m n v <= n); auto with zarith.
  apply Q_CountSectionBounds; auto with zarith.





























Qed.

Goal typed_ref_lemma_ReverseIdempotentLeft.
Hint ReverseIdempotentLeft,property.
Proof.
  Require Import Psatz.
  intros m n K L M.
  intros.
  subst x.
  unfold P_Reverse_4_ in *.
  unfold P_Reverse_1_ in *.
  unfold P_EqualRanges_2_.
  unfold P_EqualRanges_1_.
  unfold shift_sint32 in *.
  intros.

  rewrite H0; auto with zarith.
  replace (n - m + m - 1 - 0 - i) with (n - 1 - i) by lia.

  pose ( j := n - 1 - i - m).
  assert( 0 <= j) by (subst j; lia).
  assert( m + j < n) by (subst j; lia).

  replace (n - 1 - i) with (m + j) by (subst j; lia).
  rewrite H; auto with zarith.

  subst j.
  replace (n + m - 1 - m - (n - 1 - i - m)) with (m+i) by lia.
  trivial.

Qed.

Goal typed_ref_lemma_ReverseIdempotentRight.
Hint ReverseIdempotentRight,property.
Proof.
 Require Import Psatz.
  intros m n K L M.
  intros.
  subst x.
  unfold P_Reverse_4_ in *.
  unfold P_Reverse_1_ in *.
  unfold P_EqualRanges_2_.
  unfold P_EqualRanges_1_.
  unfold shift_sint32 in *.
  intros.

  rewrite H0; auto with zarith.
  replace (n + 0 - 1 - (n - m) - i)  with (m - 1 -i) by lia.

  pose ( j := m - 1 - i).
  assert( 0 <= j < m) by (subst j; lia).
  replace (m - 1 - i) with (0 + j) by (subst j; lia).
  rewrite H; auto with zarith.
  subst j.

  replace (m + 0 - 1 - 0 - (m - 1 - i)) with (0 + i) by lia.
  trivial.


Qed.

Goal typed_ref_lemma_ReverseShift.
Hint ReverseShift,property.
Proof.
  Require Import Psatz.
  intros p q K L.
  intros.
  unfold P_Reverse_6_ in *.
  unfold P_Reverse_5_ in *.
  unfold P_Reverse_1_ in *.
  unfold shift_sint32 in *.
  intros.

  assert(Shift: forall z k l, (shift (shift z k) l) = (shift z (k + l))).
  {
    intros.
    unfold shift.
    simpl.
    replace (offset z + k + l) with (offset z + (k + l)) by lia.
    trivial.
  }

  replace (shift a (p + i)) with (shift (shift a p) (0 + i)).
  - rewrite H; auto with zarith.
    rewrite Shift.
    replace (p + (q - p + 0 - 1 - 0 - i)) with (q + p - 1 - p - i) by lia.
    trivial.
  - rewrite Shift.
    replace (0 + i) with i by lia.
    trivial.






Qed.

Goal typed_ref_lemma_ReverseSwitch.
Hint ReverseSwitch,property.
Proof.
  intros p q r K L.
  intros.
  unfold P_Reverse_4_ in *.
  unfold P_Reverse_1_ in *.
  unfold shift_sint32 in *.
  intros.
  replace (r + q - p + p - 1 - r - i) with (q - 1 - i) by auto with zarith.
  assert(p + i < q) by auto with zarith.













Qed.

Goal typed_ref_lemma_ReverseUnion.
Hint ReverseUnion,property.
Proof.
  intros p q K L.
  intros.
  unfold P_Reverse_4_ in *.
  unfold P_Reverse_1_ in *.
  unfold shift_sint32 in *.
  intros.

  assert(X: i < p \/ i >= p) by tauto.
  destruct X as [lower|upper].
  {
    rewrite H1; auto with zarith.
    replace (p + q - 1 - 0 - i) with (q + p - 1 - 0 - i) by auto with zarith.
    trivial.
  }
  {
       pose (j := i - p).
       replace (0 + i) with (p + j).
       replace (q + p - 1 - 0 - i) with (q + p - 1 - p - j).
       rewrite H2; auto with zarith.
       - subst j; auto with zarith.
       - subst j; auto with zarith.
       - subst j; auto with zarith.
       - subst j; auto with zarith.
  }








Qed.

Goal typed_ref_lemma_SortedShift.
Hint SortedShift,property.
Proof.
  Require Import Psatz.
  unfold P_Sorted_2_.
  unfold P_Sorted_1_ in *.
  unfold shift_sint32 in *.
  intros l r L a.
  intros.

  assert(Assoc: forall q m n, shift (shift q m) n = shift q (m+n)).
  {
    intros.
    unfold shift.
    simpl.
    auto with zarith.
    replace (offset q + m + n) with (offset q + (m + n)) by lia.
    trivial.
  }

  rewrite Assoc.
  rewrite Assoc.
  apply H1; lia.





























Qed.

Goal typed_ref_lemma_StrictLowerBoundShift.
Hint StrictLowerBoundShift,property.
Proof.

  Require Import Psatz.
  unfold P_StrictLowerBound in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_2 + (i0 - i_2)) by lia.

  assert(Assoc: forall q m n, shift (shift q m) n = shift q (m+n)).
  {
    intros.
    unfold shift.
    simpl.
    auto with zarith.
    replace (offset q + m + n) with (offset q + (m + n)) by lia.
    trivial.
  }
  rewrite <- Assoc.
  apply H0; lia.





























Qed.

Goal typed_ref_lemma_StrictUpperBoundShift.
Hint StrictUpperBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_StrictUpperBound in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_1 + (i0 - i_1)) by lia.
  assert(Assoc: forall q m n, shift (shift q m) n = shift q (m+n)).
  {
    intros.
    unfold shift.
    simpl.
    auto with zarith.
    replace (offset q + m + n) with (offset q + (m + n)) by lia.
    trivial.
  }
  rewrite <- Assoc.
  apply H0; lia.





























Qed.


