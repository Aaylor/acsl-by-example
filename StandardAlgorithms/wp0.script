(* Generated by Frama-C WP *)

Goal typed_ref_external_lemma_AdjacentDifferenceInverse.
Hint AdjacentDifferenceInverse,property.
Proof.
  intros n L K A B.
  intros H.

  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros.
    unfold P_Unchanged_2_ in *.
    unfold P_Unchanged_1_ in *.
    intros.
    intuition.
  }
  {
    intros.
    Require Import Psatz.
    replace (Z.succ z) with (1+z) in * by lia.

    assert(X: P_Unchanged_2_ L K A z). {
      apply H1; auto with zarith.
      - apply Q_UnchangedSection with (i := 1+z); auto with zarith.
      - apply Q_PartialSumSection with (i := 1+z); auto with zarith.
      - apply Q_AdjacentDifferenceSection with (i := 1+z); auto with zarith.
    } 

    unfold P_Unchanged_2_.
    unfold P_Unchanged_1_.
    intros.

    assert(Y: i < z \/ i = z) by lia.
    destruct Y as [less|equal].
    {
      apply X; auto with zarith.
    }
    {
      rewrite equal.
      rewrite H3; auto with zarith.
      rewrite Q_AccumulateDefaultNext; auto with zarith.
      rewrite H2; auto with zarith.
      rewrite <- H4; auto with zarith.

      assert (Z: z = 0 \/ z > 0) by lia.
      destruct Z as [zero|pos].
      {
        rewrite zero.
        rewrite Q_DifferenceEmptyOrSingle; auto with zarith.
        rewrite <- Q_AccumulateDefault0.
        lia.
      }
      {
        rewrite Q_DifferenceNext; auto with zarith.
        cut ((K .[ shift_sint32 A (z - 1)]) = L_Accumulate_2_ L B z).
        - lia.
        - rewrite <- X; auto with zarith.
          rewrite H3; auto with zarith.
          replace (1 + (z-1)) with z by lia.
          trivial.
      }
    }
  }
Qed.

Goal typed_ref_external_lemma_CountBounds.
Hint CountBounds,property.
Proof.
  Require Import Psatz.
  intros v n M a.
  intros.
  subst x.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    (* base step *)
    rewrite <- Q_CountEmpty; auto with zarith.
  }
  {
    (* induction step *)
    intros.
    replace (Z.succ z) with (1 + z) by lia.
    assert (X: M.[ shift a z] = v \/ M.[ shift a z] <> v) by tauto.

     elim X; intros.
     {
        rewrite Q_CountOneHit; auto with zarith.
     }
     {
        rewrite <- Q_CountOneMiss; auto with zarith.
     }
  }
Qed.

Goal typed_ref_external_lemma_CountMonotonic.
Hint CountMonotonic,property.
Proof.
  Require Import Psatz.
  intros v m n M a.
  intros.
  replace (L_Count M a n v)
    with  ((L_Count M a m v) + (L_Count M (shift a m) (n-m) v)).
  {
     cut (0 <= L_Count M (shift a m) (n - m) v).
     lia.
     apply Q_CountBounds; auto with zarith.
  }
  {
     rewrite <- Q_CountUnion; auto with zarith.
     replace (n-m+m) with n by lia.
     trivial.
  }

Qed.

Goal typed_ref_external_lemma_CountUnion.
Hint CountUnion,property.
Proof.
  Require Import Psatz.
  intros v n k M a.
  intros.
  unfold shift_sint32 in *.
  apply natlike_rec2 with (z := k); auto with zarith.
  - replace (L_Count M (shift a n) 0 v) with 0 by (rewrite <- Q_CountEmpty; auto with zarith).
    auto with zarith.
  - intros.
    replace (Z.succ z) with (1 + z) by lia.
    replace (1+z+n) with (1+(z+n)) by lia.
    rewrite Q_CountOne; auto with zarith.
    rewrite H2.
    symmetry.

    rewrite Q_CountOne; auto with zarith.
    unfold shift_sint32.
    replace (shift (shift a n) z) with (shift a (z+n)).
    +  auto with zarith.
    + unfold shift; simpl.
      replace (offset a + (z + n)) with (offset a + n + z) by lia.
      trivial.
Qed.

Goal typed_ref_external_lemma_RemoveCountMonotonic.
Hint RemoveCountMonotonic,property.
Proof.
  Require Import Psatz.
  unfold L_RemoveCount in *.
  intros v m n M a.
  intros.

  cut(m + (L_Count M a n v) <= n + (L_Count M a m v)); auto with zarith.
  replace (n) with ((n-m) + m) by lia.
  rewrite Q_CountUnion with (i := n-m); auto with zarith.
  unfold shift_sint32.
  cut (L_Count M (shift a m) (n - m) v <= n - m); auto with zarith.
  apply Q_CountBounds; auto with zarith.
Qed.

Goal typed_ref_external_lemma_RetainAllButOneMiss.
Hint RetainAllButOneMiss,property.
Proof.
  intros.
  unfold P_RetainAllButOne in *.
  unfold shift_sint32 in *.

  remember a_1 as A.
  remember a as B.
  remember i_2 as v.
  remember i_1 as m.


  intros.
  unfold is_sint32 in *.
  rewrite <- Q_CountOneMiss.
  rewrite <- Q_CountOneMiss.
  unfold is_sint32 in *.
  rewrite H2; auto with zarith.
  auto with zarith.
  auto.
  unfold shift_sint32.
Qed.

Goal typed_ref_external_remove_copy_loop_inv_stable_preserved.
Hint preserved,remove_copy,stable.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_ref_external_stack_push_wd_post_2.
Hint default,property,stack_push_wd.
Proof.
(* auto with zarith. *)
Qed.


