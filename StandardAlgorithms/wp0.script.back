(* Generated by Frama-C WP *)

Goal typed_ref_external_lemma_RemoveCountMono.
Hint RemoveCountMono,property.
Proof.
  intros.
  (* how to apply natlike_rec2 ? *)
Qed.

Goal typed_ref_external_remove_copy_loop_inv_jump2_preserved_part1.
Hint jump,part-0,preserved,remove_copy.
Proof.
  unfold P_RemoveCountJump in *.

  intros.

  remember a_0 as a.
  remember b_0 as b.
  remember n_0 as n.
  remember v_0 as v.
  remember i_0 as i.
  remember i_1 as k.
  remember Mint_0 as M0.
  remember (M0 .[ shift b (L_RemoveCount M0 a i v) <- M0 .[ shift a i]]) as M1.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  assert(BA: shift b (L_RemoveCount M0 a i v) <> shift a k).
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym.
    assumption.

  rewrite HeqM1 in H27.
  rewrite access_update_neq in H27; auto.

   case_lt k i. 
  + intros less.
   assert(Y: forall k_0 : int, k_0 < k -> 0 <= k_0 -> M1 .[shift a k_0] = M0 .[shift a k_0]).
      intros.
      rewrite HeqM1.
      rewrite access_update_neq; auto with zarith. 
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym.
      assumption.

    assert(M1v: v <> M1 .[ shift a i]).
      rewrite HeqM1.
      rewrite access_update_neq; auto with zarith.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym.
      assumption.

    rewrite Q_RemoveCountRead with (Mint_0 := M0); auto.
    
    rewrite Q_RemoveCountMiss; auto.
    apply Zgt_lt.
    rewrite Q_RemoveCountRead with (Mint_0 := M0); auto.

    assert(L_RemoveCount M0 a k v < L_RemoveCount M0 a i v).
      apply H11; auto with zarith.
    auto with zarith.

    intros.
    subst a_1.
    rewrite HeqM1.
    rewrite access_update_neq; auto with zarith. 
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.

  + intros.
    assert(equal: k = i) by omega.
    rewrite equal in *.

    assert(v <> M1 .[ shift a i]).
      rewrite HeqM1.
      rewrite access_update_neq; auto with zarith.

    assert(Y: forall k_0 : int, k_0 < i -> 0 <= k_0 -> M1 .[shift a k_0] = M0 .[shift a k_0]).
      intros.
      rewrite HeqM1.
      rewrite access_update_neq; auto with zarith.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption. 

    rewrite Q_RemoveCountRead with (Mint_0 := M0); auto.
    apply Zgt_lt.
    rewrite Q_RemoveCountMiss; auto.
    rewrite Q_RemoveCountRead with (Mint_0 := M0); auto with zarith.

Qed.

Goal typed_ref_external_remove_copy_loop_inv_mono2_preserved_part1.
Hint mono,part-0,preserved,remove_copy.
Proof.
  unfold P_RemoveCountMonotonic in *.
  intros.

  remember a_0 as a.
  remember b_0 as b.
  remember n_0 as n.
  remember v_0 as v.
  remember i_0 as i.
  remember Mint_0 as M0.
  remember (M0.[shift b (L_RemoveCount M0 a i v) <- M0 .[ shift a i]]) as M1.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  remember i_1 as k.

  case_lt k (1+i).
  + intros.

    rewrite Q_RemoveCountMiss; auto.
    rewrite Q_RemoveCountRead with (Mint_0 := M0); auto.
    apply Zge_le.
    rewrite Q_RemoveCountRead with (Mint_0 := M0); auto.
    apply Zle_ge.

    assert(have: L_RemoveCount M0 a k v <= L_RemoveCount M0 a i v).
      apply H8; auto with zarith.

    omega.

    - intros.
      subst a_1.
      rewrite HeqM1.
      rewrite access_update_neq; auto.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.

 
    - intros.
      subst a_1.
      rewrite HeqM1.
      rewrite access_update_neq; auto.
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.

    - rewrite HeqM1.
      rewrite access_update_neq; auto.     
      apply separated_1 with (n) (n); auto with zarith.
      apply separated_sym; assumption.

  + intros.
    assert(equal: k = 1 + i) by auto with zarith.
    rewrite equal.
    omega.
Qed.

Goal typed_ref_external_remove_copy_loop_inv_preserved2_preserved_part1.
Hint part-0,preserved,preserved2,remove_copy.
Proof.
  unfold P_PreserveCount in *.
  unfold is_uint32 in *.
  intros.

  remember a_0 as a.
  remember b_0 as b.
  remember n_0 as n.
  remember v_0 as v.
  remember i_0 as i.
  remember Mint_0 as M0.
  remember (M0 .[ shift b (L_RemoveCount M0 a i v) <- M0 .[ shift a i]]) as M1.

  rewrite shift_zero in *.
  rewrite shift_zero in *.


 
  rewrite A_CountAxiomatic.Q_CountRead with (Mint_0 := M0); auto.

  assert(X: M0 .[ shift a i] = x_0 \/ M0 .[ shift a i] <> x_0) by tauto.
  case X.
  + intros equal.

    rewrite A_CountAxiomatic.Q_CountOneHit; auto.
    symmetry.
    rewrite A_CountAxiomatic.Q_CountOneHit; auto.
    symmetry.

    cut(A_CountAxiomatic.L_Count M0 a i x_0 = A_CountAxiomatic.L_Count M1 b (L_RemoveCount M0 a i v) x_0).
      auto with zarith.

    symmetry.
    rewrite A_CountAxiomatic.Q_CountRead with (Mint_0 := M0); auto.
    symmetry.
    apply H26; auto with zarith.

    - unfold P_EqualRanges_2_.
      intros.
      rewrite HeqM1.
      rewrite access_update_neq; auto.
      apply shift_injective_neq; auto with zarith.

   -  intros.
      rewrite HeqM1.
      rewrite access_update; auto.

  + intros not_equal.
    rewrite <- A_CountAxiomatic.Q_CountOneMiss; auto.
    symmetry.
    rewrite <- A_CountAxiomatic.Q_CountOneMiss; auto.
    rewrite A_CountAxiomatic.Q_CountRead with (Mint_0 := M0); auto.
    symmetry.
    apply H26; auto with zarith.

    - unfold P_EqualRanges_2_.
      intros.
      rewrite HeqM1.
      rewrite access_update_neq; auto.
      apply shift_injective_neq; auto with zarith.

    - rewrite HeqM1.
      rewrite access_update; auto.

  + unfold P_EqualRanges_2_.
    intros.
    rewrite HeqM1.
    rewrite access_update_neq; auto.
    apply separated_1 with (n) (n); auto with zarith.
    apply separated_sym; assumption.
Qed.

Goal typed_ref_external_remove_copy_loop_inv_stable2_preserved_part1.
Hint part-0,preserved,remove_copy,stable2.
Proof.
  unfold P_StableRemove in *.
  intros.

  rewrite shift_zero in *.
  rewrite shift_zero in *.

  remember i_1 as k.
  remember Mint_0 as M0.


  assert(X: forall m, 0 <= m < n_0 -> shift a_0 m <> shift b_0 (L_RemoveCount M0 a_0 i_0 v_0)).
    intros.
    apply separated_1 with (n_0) (n_0); auto with zarith.

  assert(Xk: shift a_0 k <> shift b_0 (L_RemoveCount M0 a_0 i_0 v_0)).
      apply X; omega.

  rewrite access_update_neq in *; auto with zarith.
  remember ((M0.[shift b_0 (L_RemoveCount M0 a_0 i_0 v_0) <- M0.[shift a_0 i_0]])) as M1.

  assert(Read: (L_RemoveCount M1 a_0 k v_0) = (L_RemoveCount M0 a_0 k v_0)).
    rewrite Q_RemoveCountRead with (Mint_0 := M0); auto with zarith.

    unfold P_EqualRanges_2_.
    intros.
    rewrite HeqM1.
    rewrite access_update_neq; auto with zarith.
    apply addr_neq_symmetry. 
    apply X; omega.

  case_lt k i_0. 
  + intros.
    rewrite Read.
    rewrite HeqM1.
    rewrite access_update_neq.
    - apply H15; auto with zarith.
    - assert(L_RemoveCount M0 a_0 k v_0 < L_RemoveCount M0 a_0 i_0 v_0).
        apply H10; auto with zarith.
      apply shift_injective_neq; omega.

  + intros.
    assert(equal: k = i_0) by omega.
    rewrite equal in *.
    rewrite Read.
    rewrite HeqM1.
    rewrite access_update; auto.
Qed.


